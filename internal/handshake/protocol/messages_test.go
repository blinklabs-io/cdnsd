// Copyright 2025 Blink Labs Software
//
// Use of this source code is governed by an MIT-style
// license that can be found in the LICENSE file or at
// https://opensource.org/licenses/MIT.

package protocol

import (
	"encoding/hex"
	"net"
	"reflect"
	"testing"

	"github.com/blinklabs-io/cdnsd/internal/handshake"
)

func TestMsgVersionEncodeDecode(t *testing.T) {
	testDefs := []struct {
		message   Message
		binaryHex string
	}{
		// Captured from hsd
		{
			binaryHex: "030000000100000000000000e690136900000000e69013690000000000000000000000000000000000000000000000ffff60e6a250000000000000000000000000000000000000000046c40000000000000000000000000000000000000000000000000000000000000000002de918cb7d2b6e6e0b2f6873643a382e302e302f1ca0040000",
			message: &MsgVersion{
				Version:  0x3,
				Services: 0x1,
				Time:     0x691390e6,
				Remote: NetAddress{
					Time:     0x691390e6,
					Services: 0x0,
					Host:     net.IP{0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0xff, 0xff, 0x60, 0xe6, 0xa2, 0x50},
					Port:     0x46c4,
					Key:      [33]uint8{0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0}},
				Nonce:   [8]uint8{0x2d, 0xe9, 0x18, 0xcb, 0x7d, 0x2b, 0x6e, 0x6e},
				Agent:   "/hsd:8.0.0/",
				Height:  0x4a01c,
				NoRelay: false,
			},
		},
		// Captured from our own Version message
		{
			binaryHex: "0100000000000000000000003f9e1369000000003f9e13690000000000000000000000000000000000000000000000ffff000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000054990d22ec7e7401072f63646e73642f0000000001",
			message: &MsgVersion{
				Version:  1,
				Services: 0,
				Time:     0x69139e3f,
				Remote: NetAddress{
					Time:     0x69139e3f,
					Services: 0,
					Host:     net.IP{0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0xff, 0xff, 0x0, 0x0, 0x0, 0x0},
					Port:     0,
				},
				Nonce:   [8]byte{0x54, 0x99, 0xd, 0x22, 0xec, 0x7e, 0x74, 0x1},
				Agent:   "/cdnsd/",
				Height:  0,
				NoRelay: true,
			},
		},
	}
	for _, testDef := range testDefs {
		binaryData, err := hex.DecodeString(testDef.binaryHex)
		if err != nil {
			t.Fatalf("unexpected error decoding hex: %s", err)
		}
		testMsg := new(MsgVersion)
		if err := testMsg.Decode(binaryData); err != nil {
			t.Fatalf("unexpected error decoding message: %s", err)
		}
		if !reflect.DeepEqual(testMsg, testDef.message) {
			t.Fatalf("did not get expected message after decode:\n     got: %#v\n  wanted: %#v", testMsg, testDef.message)
		}
		testEncoded := testMsg.Encode()
		testEncodedHex := hex.EncodeToString(testEncoded)
		if testEncodedHex != testDef.binaryHex {
			t.Fatalf("did not get expected binary hex after encode:\n     got: %s\n  wanted: %s", testEncodedHex, testDef.binaryHex)
		}
	}
}

func TestMsgAddrEncodeDecode(t *testing.T) {
	testDefs := []struct {
		message   Message
		binaryHex string
	}{
		// Modified (truncated) from data captured from hsd
		{
			binaryHex: "015757fc680000000003000000000000000000000000000000000000ffff2d4f5fe40000000000000000000000000000000000000000062f000000000000000000000000000000000000000000000000000000000000000000",
			message: &MsgAddr{
				Peers: []NetAddress{
					{
						Time:     0x68fc5757,
						Services: 0x3,
						Host:     net.IP{0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0xff, 0xff, 0x2d, 0x4f, 0x5f, 0xe4},
						Port:     0x62f,
					},
				},
			},
		},
	}
	for _, testDef := range testDefs {
		binaryData, err := hex.DecodeString(testDef.binaryHex)
		if err != nil {
			t.Fatalf("unexpected error decoding hex: %s", err)
		}
		testMsg := new(MsgAddr)
		if err := testMsg.Decode(binaryData); err != nil {
			t.Fatalf("unexpected error decoding message: %s", err)
		}
		if !reflect.DeepEqual(testMsg, testDef.message) {
			t.Fatalf("did not get expected message after decode:\n     got: %#v\n  wanted: %#v", testMsg, testDef.message)
		}
		testEncoded := testMsg.Encode()
		testEncodedHex := hex.EncodeToString(testEncoded)
		if testEncodedHex != testDef.binaryHex {
			t.Fatalf("did not get expected binary hex after encode:\n     got: %s\n  wanted: %s", testEncodedHex, testDef.binaryHex)
		}
	}
}

func TestMsgGetHeadersEncodeDecode(t *testing.T) {
	testDefs := []struct {
		message   Message
		binaryHex string
	}{
		// Generated by our own code
		{
			binaryHex: "015b6ef2d3c1f3cdcadfd9a030ba1811efdd17740f14e166489760741d075992e00000000000000000000000000000000000000000000000000000000000000000",
			message: &MsgGetHeaders{
				Locator: [][32]byte{
					func() [32]byte {
						foo, _ := hex.DecodeString("5b6ef2d3c1f3cdcadfd9a030ba1811efdd17740f14e166489760741d075992e0")
						return [32]byte(foo)
					}(),
				},
				StopHash: [32]byte{},
			},
		},
	}
	for _, testDef := range testDefs {
		binaryData, err := hex.DecodeString(testDef.binaryHex)
		if err != nil {
			t.Fatalf("unexpected error decoding hex: %s", err)
		}
		testMsg := new(MsgGetHeaders)
		if err := testMsg.Decode(binaryData); err != nil {
			t.Fatalf("unexpected error decoding message: %s", err)
		}
		if !reflect.DeepEqual(testMsg, testDef.message) {
			t.Fatalf("did not get expected message after decode:\n     got: %#v\n  wanted: %#v", testMsg, testDef.message)
		}
		testEncoded := testMsg.Encode()
		testEncodedHex := hex.EncodeToString(testEncoded)
		if testEncodedHex != testDef.binaryHex {
			t.Fatalf("did not get expected binary hex after encode:\n     got: %s\n  wanted: %s", testEncodedHex, testDef.binaryHex)
		}
	}
}

func TestMsgHeadersEncodeDecode(t *testing.T) {
	testDefs := []struct {
		message   Message
		binaryHex string
	}{
		// Modified (truncated) from data captured from hsd
		{
			binaryHex: "0232bb5134a541385e000000005b6ef2d3c1f3cdcadfd9a030ba1811efdd17740f14e166489760741d075992e00000000000000000000000000000000000000000000000000000000000000000000000150000000400000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000059919422c20530ece2b328adf63ec3f35a10e79375731687a81dfa7cd83a24e728b17095216d5e211ba1f61031416a51efca54eacb8c9059440c4671b0625bbe00000000ffff001c0000000000000000000000000000000000000000000000000000000000000000032a8839c741385e000000000000000000a5e40e8ba291bd7e8649747fa7fb8a7af39f5bacdb7433cd2f59710000000000000000000000000000000000000000000000000000000000000000000000060000000c00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000038180556e54cd70fd131130e154be4569945a6526d45add9ade6dbdfa34f54e25d1d56a37915cd1337b007806116ff623d973bec006280154472a6677eacbe0700000000ffff001c0000000000000000000000000000000000000000000000000000000000000000",
			message: &MsgHeaders{
				Headers: []*handshake.BlockHeader{
					&handshake.BlockHeader{
						Nonce:        0x3451bb32,
						Time:         0x5e3841a5,
						PrevBlock:    [32]uint8{0x5b, 0x6e, 0xf2, 0xd3, 0xc1, 0xf3, 0xcd, 0xca, 0xdf, 0xd9, 0xa0, 0x30, 0xba, 0x18, 0x11, 0xef, 0xdd, 0x17, 0x74, 0xf, 0x14, 0xe1, 0x66, 0x48, 0x97, 0x60, 0x74, 0x1d, 0x7, 0x59, 0x92, 0xe0},
						NameRoot:     [32]uint8{0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0},
						ExtraNonce:   [24]uint8{0x0, 0x0, 0x0, 0x15, 0x0, 0x0, 0x0, 0x4, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0},
						ReservedRoot: [32]uint8{0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0},
						WitnessRoot:  [32]uint8{0x59, 0x91, 0x94, 0x22, 0xc2, 0x5, 0x30, 0xec, 0xe2, 0xb3, 0x28, 0xad, 0xf6, 0x3e, 0xc3, 0xf3, 0x5a, 0x10, 0xe7, 0x93, 0x75, 0x73, 0x16, 0x87, 0xa8, 0x1d, 0xfa, 0x7c, 0xd8, 0x3a, 0x24, 0xe7},
						MerkleRoot:   [32]uint8{0x28, 0xb1, 0x70, 0x95, 0x21, 0x6d, 0x5e, 0x21, 0x1b, 0xa1, 0xf6, 0x10, 0x31, 0x41, 0x6a, 0x51, 0xef, 0xca, 0x54, 0xea, 0xcb, 0x8c, 0x90, 0x59, 0x44, 0xc, 0x46, 0x71, 0xb0, 0x62, 0x5b, 0xbe},
						Version:      0x0,
						Bits:         0x1c00ffff,
						Mask:         [32]uint8{0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0},
					},
					&handshake.BlockHeader{
						Nonce:        0x39882a03,
						Time:         0x5e3841c7,
						PrevBlock:    [32]uint8{0x0, 0x0, 0x0, 0x0, 0x0, 0xa5, 0xe4, 0xe, 0x8b, 0xa2, 0x91, 0xbd, 0x7e, 0x86, 0x49, 0x74, 0x7f, 0xa7, 0xfb, 0x8a, 0x7a, 0xf3, 0x9f, 0x5b, 0xac, 0xdb, 0x74, 0x33, 0xcd, 0x2f, 0x59, 0x71},
						NameRoot:     [32]uint8{0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0},
						ExtraNonce:   [24]uint8{0x0, 0x0, 0x0, 0x6, 0x0, 0x0, 0x0, 0xc, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0},
						ReservedRoot: [32]uint8{0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0},
						WitnessRoot:  [32]uint8{0x38, 0x18, 0x5, 0x56, 0xe5, 0x4c, 0xd7, 0xf, 0xd1, 0x31, 0x13, 0xe, 0x15, 0x4b, 0xe4, 0x56, 0x99, 0x45, 0xa6, 0x52, 0x6d, 0x45, 0xad, 0xd9, 0xad, 0xe6, 0xdb, 0xdf, 0xa3, 0x4f, 0x54, 0xe2},
						MerkleRoot:   [32]uint8{0x5d, 0x1d, 0x56, 0xa3, 0x79, 0x15, 0xcd, 0x13, 0x37, 0xb0, 0x7, 0x80, 0x61, 0x16, 0xff, 0x62, 0x3d, 0x97, 0x3b, 0xec, 0x0, 0x62, 0x80, 0x15, 0x44, 0x72, 0xa6, 0x67, 0x7e, 0xac, 0xbe, 0x7},
						Version:      0x0,
						Bits:         0x1c00ffff,
						Mask:         [32]uint8{0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0},
					},
				},
			},
		},
	}
	for _, testDef := range testDefs {
		binaryData, err := hex.DecodeString(testDef.binaryHex)
		if err != nil {
			t.Fatalf("unexpected error decoding hex: %s", err)
		}
		testMsg := new(MsgHeaders)
		if err := testMsg.Decode(binaryData); err != nil {
			t.Fatalf("unexpected error decoding message: %s", err)
		}
		if !reflect.DeepEqual(testMsg, testDef.message) {
			t.Fatalf("did not get expected message after decode:\n     got: %#v\n  wanted: %#v", testMsg, testDef.message)
		}
		testEncoded := testMsg.Encode()
		testEncodedHex := hex.EncodeToString(testEncoded)
		if testEncodedHex != testDef.binaryHex {
			t.Fatalf("did not get expected binary hex after encode:\n     got: %s\n  wanted: %s", testEncodedHex, testDef.binaryHex)
		}
	}
}
